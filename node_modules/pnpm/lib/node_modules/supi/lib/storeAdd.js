"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("@pnpm/logger");
const utils_1 = require("@pnpm/utils");
const parseWantedDependencies_1 = require("./parseWantedDependencies");
async function default_1(fuzzyDeps, opts) {
    const reporter = opts && opts.reporter;
    if (reporter) {
        logger_1.streamParser.on('data', reporter);
    }
    const deps = parseWantedDependencies_1.default(fuzzyDeps, {
        allowNew: true,
        currentPrefs: {},
        defaultTag: opts.tag || 'latest',
        dev: false,
        devDependencies: {},
        optional: false,
        optionalDependencies: {},
    });
    let hasFailures = false;
    const prefix = opts.prefix || process.cwd();
    const registries = opts.registries || {
        default: 'https://registry.npmjs.org/',
    };
    await Promise.all(deps.map(async (dep) => {
        try {
            const pkgResponse = await opts.storeController.requestPackage(dep, {
                downloadPriority: 1,
                lockfileDirectory: prefix,
                preferredVersions: {},
                prefix,
                registry: dep.alias && utils_1.pickRegistryForPackage(registries, dep.alias) || registries.default,
            });
            await pkgResponse['fetchingFiles']; // tslint:disable-line:no-string-literal
            logger_1.storeLogger.info(`+ ${pkgResponse.body.id}`);
        }
        catch (e) {
            hasFailures = true;
            logger_1.storeLogger.error(e);
        }
    }));
    await opts.storeController.saveState();
    if (reporter) {
        logger_1.streamParser.removeListener('data', reporter);
    }
    if (hasFailures) {
        const err = new Error('Some packages have not been added correctly');
        err['code'] = 'ERR_PNPM_STORE_ADD_FAILURE'; // tslint:disable-line:no-string-literal
        throw err;
    }
}
exports.default = default_1;
//# sourceMappingURL=storeAdd.js.map