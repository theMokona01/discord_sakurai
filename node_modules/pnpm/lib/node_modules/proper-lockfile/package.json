{
  "_args": [
    [
      {
        "raw": "proper-lockfile@^2.0.1",
        "scope": null,
        "escapedName": "proper-lockfile",
        "name": "proper-lockfile",
        "rawSpec": "^2.0.1",
        "spec": ">=2.0.1 <3.0.0",
        "type": "range"
      },
      "/home/zoltan/src/pnpm/pnpm/packages/pnpm/node_modules/@pnpm/fs-locker"
    ]
  ],
  "_from": "proper-lockfile@>=2.0.1 <3.0.0",
  "_id": "proper-lockfile@2.0.1",
  "_inCache": true,
  "_location": "/proper-lockfile",
  "_nodeVersion": "6.10.2",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/proper-lockfile-2.0.1.tgz_1493031121568_0.3492889911867678"
  },
  "_npmUser": {
    "name": "satazor",
    "email": "andremiguelcruz@msn.com"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "proper-lockfile@^2.0.1",
    "scope": null,
    "escapedName": "proper-lockfile",
    "name": "proper-lockfile",
    "rawSpec": "^2.0.1",
    "spec": ">=2.0.1 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/@pnpm/fs-locker"
  ],
  "_resolved": "https://registry.npmjs.org/proper-lockfile/-/proper-lockfile-2.0.1.tgz",
  "_shasum": "159fb06193d32003f4b3691dd2ec1a634aa80d1d",
  "_shrinkwrap": null,
  "_spec": "proper-lockfile@^2.0.1",
  "_where": "/home/zoltan/src/pnpm/pnpm/packages/pnpm/node_modules/@pnpm/fs-locker",
  "author": {
    "name": "IndigoUnited",
    "email": "hello@indigounited.com",
    "url": "http://indigounited.com"
  },
  "bugs": {
    "url": "https://github.com/IndigoUnited/node-proper-lockfile/issues/"
  },
  "dependencies": {
    "graceful-fs": "^4.1.2",
    "retry": "^0.10.0"
  },
  "description": "A inter-process and inter-machine lockfile utility that works on a local or network file system.",
  "devDependencies": {
    "@satazor/eslint-config": "^3.1.1",
    "async": "^2.0.0",
    "buffered-spawn": "^3.0.0",
    "coveralls": "^2.11.6",
    "eslint": "^3.5.0",
    "eslint-plugin-react": "^6.2.0",
    "expect.js": "^0.3.1",
    "istanbul": "^0.4.1",
    "mocha": "^3.0.2",
    "rimraf": "^2.5.0",
    "stable": "^0.1.5"
  },
  "directories": {},
  "dist": {
    "shasum": "159fb06193d32003f4b3691dd2ec1a634aa80d1d",
    "tarball": "https://registry.npmjs.org/proper-lockfile/-/proper-lockfile-2.0.1.tgz"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "gitHead": "f53b29c6c74b895ba7d5b58938e355ebf20b7bce",
  "homepage": "https://github.com/IndigoUnited/node-proper-lockfile#readme",
  "keywords": [
    "lock",
    "locking",
    "file",
    "lockfile",
    "fs",
    "rename",
    "cross",
    "machine"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "satazor",
      "email": "andremiguelcruz@msn.com"
    }
  ],
  "name": "proper-lockfile",
  "optionalDependencies": {},
  "readme": "# proper-lockfile\n\n[![NPM version][npm-image]][npm-url] [![Downloads][downloads-image]][npm-url] [![Build Status][travis-image]][travis-url] [![Coverage Status][coveralls-image]][coveralls-url] [![Dependency status][david-dm-image]][david-dm-url] [![Dev Dependency status][david-dm-dev-image]][david-dm-dev-url]\n\n[npm-url]:https://npmjs.org/package/proper-lockfile\n[downloads-image]:http://img.shields.io/npm/dm/proper-lockfile.svg\n[npm-image]:http://img.shields.io/npm/v/proper-lockfile.svg\n[travis-url]:https://travis-ci.org/IndigoUnited/node-proper-lockfile\n[travis-image]:http://img.shields.io/travis/IndigoUnited/node-proper-lockfile/master.svg\n[coveralls-url]:https://coveralls.io/r/IndigoUnited/node-proper-lockfile\n[coveralls-image]:https://img.shields.io/coveralls/IndigoUnited/node-proper-lockfile/master.svg\n[david-dm-url]:https://david-dm.org/IndigoUnited/node-proper-lockfile\n[david-dm-image]:https://img.shields.io/david/IndigoUnited/node-proper-lockfile.svg\n[david-dm-dev-url]:https://david-dm.org/IndigoUnited/node-proper-lockfile#info=devDependencies\n[david-dm-dev-image]:https://img.shields.io/david/dev/IndigoUnited/node-proper-lockfile.svg\n\nAn inter-process and inter-machine lockfile utility that works on a local or network file system.\n\n\n## Installation\n\n`$ npm install proper-lockfile`\n\n\n## Design\n\nThere are various ways to achieve [file locking](http://en.wikipedia.org/wiki/File_locking).\n\nThis library utilizes the `mkdir` strategy which works atomically on any kind of file system, even network based ones.\nThe lockfile path is based on the file path you are trying to lock by suffixing it with `.lock`.\n\nWhen a lock is successfully acquired, the lockfile's `mtime` (modified time) is periodically updated to prevent staleness. This allows to effectively check if a lock is stale by checking its `mtime` against a stale threshold. If the update of the mtime fails several times, the lock might be compromised. The `mtime` is [supported](http://en.wikipedia.org/wiki/Comparison_of_file_systems) in almost every `filesystem`.\n\n\n### Comparison\n\nThis library is similar to [lockfile](https://github.com/isaacs/lockfile) but the later has some drawbacks:\n\n- It relies on `open` with `O_EXCL` flag which has problems in network file systems. `proper-lockfile` uses `mkdir` which doesn't have this issue.\n\n> O_EXCL is broken on NFS file systems; programs which rely on it for performing locking tasks will contain a race condition.\n\n- The lockfile staleness check is done via `ctime` (creation time) which is unsuitable for long running processes. `proper-lockfile` constantly updates lockfiles `mtime` to do proper staleness check.\n\n- It does not check if the lockfile was compromised which can led to undesirable situations. `proper-lockfile` checks the lockfile when updating the `mtime`.\n\n\n### Compromised\n\n`proper-lockfile` does not detect cases in which:\n\n- A `lockfile` is manually removed and someone else acquires the lock right after\n- Different `stale`/`update` values are being used for the same file, possibly causing two locks to be acquired on the same file\n\n`proper-lockfile` detects cases in which:\n\n- Updates to the `lockfile` fail\n- Updates take longer than expected, possibly causing the lock to became stale for a certain amount of time\n\n\nAs you see, the first two are a consequence of bad usage. Technically, it was possible to detect the first two but it would introduce complexity and eventual race conditions.\n\n\n## Usage\n\n### .lock(file, [options], [compromised], callback)\n\nTries to acquire a lock on `file`.\n\nIf the lock succeeds, a `release` function is provided that should be called when you want to release the lock.   \nIf the lock gets compromised, the `compromised` function will be called. The default `compromised` function is a simple `throw err` which will probably cause the process to die. Specify it to handle the way you desire.\n\nAvailable options:\n\n- `stale`: Duration in milliseconds in which the lock is considered stale, defaults to `10000` (minimum value is `5000`)\n- `update`: The interval in milliseconds in which the lockfile's `mtime` will be updated, defaults to `stale/2` (minimum value is `1000`, maximum value is `stale/2`)\n- `retries`: The number of retries or a [retry](https://www.npmjs.org/package/retry) options object, defaults to `0`\n- `realpath`: Resolve symlinks using realpath, defaults to `true` (note that if `true`, the `file` must exist previously)\n- `fs`: A custom fs to use, defaults to `graceful-fs`\n\n\n```js\nconst lockfile = require('proper-lockfile');\n\nlockfile.lock('some/file', (err, release) => {\n    if (err) {\n        throw err;  // Lock failed\n    }\n\n    // Do something while the file is locked\n\n    // Call the provided release function when you're done\n    release();\n\n    // Note that you can optionally handle release errors\n    // Though it's not mandatory since it will eventually stale\n    /*release((err) => {\n        // At this point the lock was effectively released or an error\n        // occurred while removing it\n        if (err) {\n            throw err;\n        }\n    });*/\n});\n```\n\n\n### .unlock(file, [options], [callback])\n\nReleases a previously acquired lock on `file`.\n\nWhenever possible you should use the `release` function instead (as exemplified above). Still there are cases in which its hard to keep a reference to it around code. In those cases `unlock()` might be handy.\n\nThe `callback` is optional because even if the removal of the lock failed, the lockfile's `mtime` will no longer be updated causing it to eventually stale.\n\nAvailable options:\n\n- `realpath`: Resolve symlinks using realpath, defaults to `true` (note that if `true`, the `file` must exist previously)\n- `fs`: A custom fs to use, defaults to `graceful-fs`\n\n\n```js\nconst lockfile = require('proper-lockfile');\n\nlockfile.lock('some/file', (err) => {\n    if (err) {\n        throw err;\n    }\n\n    // Later..\n    lockfile.unlock('some/file');\n\n    // or..\n    /*lockfile.unlock('some/file', (err) => {\n        // At this point the lock was effectively released or an error\n        // occurred while removing it\n        if (err) {\n            throw err;\n        }\n    });*/\n});\n```\n\n### .check(file, [options], callback)\n\nCheck if the file is locked and its lockfile is not stale. Callback is called with callback(error, isLocked).\n\nAvailable options:\n\n- `stale`: Duration in milliseconds in which the lock is considered stale, defaults to `10000` (minimum value is `5000`)\n- `realpath`: Resolve symlinks using realpath, defaults to `true` (note that if `true`, the `file` must exist previously)\n- `fs`: A custom fs to use, defaults to `graceful-fs`\n\n\n```js\nconst lockfile = require('proper-lockfile');\n\nlockfile.check('some/file', (err, isLocked) => {\n    if (err) {\n        throw err;\n    }\n\n    // isLocked will be true if 'some/file' is locked, false otherwise\n});\n```\n\n### .lockSync(file, [options], [compromised])\n\nSync version of `.lock()`.   \nReturns the `release` function or throws on error.\n\n\n### .unlockSync(file, [options])\n\nSync version of `.unlock()`.   \nThrows on error.\n\n### .checkSync(file, [options])\n\nSync version of `.check()`.\nReturns a boolean or throws on error.\n\n\n## Graceful exit\n\n`proper-lockfile` automatically remove locks if the process exists. Though, `SIGINT` and `SIGTERM` signals\nare handled differently by `nodejs` in the sense that they do not fire a `exit` event on the `process`.\nTo avoid this common issue that `CLI` developers have, please do the following:\n\n\n```js\n// Map SIGINT & SIGTERM to process exit\n// so that lockfile removes the lockfile automatically\nprocess\n.once('SIGINT', () => process.exit(1))\n.once('SIGTERM', () => process.exit(1));\n```\n\n\n## Tests\n\n`$ npm test`   \n`$ npm test-cov` to get coverage report\n\nThe test suite is very extensive. There's even a stress test to guarantee exclusiveness of locks.\n\n\n## License\n\nReleased under the [MIT License](http://www.opensource.org/licenses/mit-license.php).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/IndigoUnited/node-proper-lockfile.git"
  },
  "scripts": {
    "lint": "eslint '{*.js,lib/**/*.js,test/**/*.js}' --ignore-pattern=test/coverage",
    "test": "mocha",
    "test-cov": "istanbul cover --dir test/coverage _mocha && echo open test/coverage/lcov-report/index.html",
    "test-travis": "istanbul cover _mocha --report lcovonly && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js"
  },
  "version": "2.0.1"
}
